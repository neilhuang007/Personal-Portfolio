{
  "projects": [
    {
      "id": "aeternus-argus",
      "title": "Aeternus Argus - AI Network Security System",
      "category": "python",
      "subcategories": ["machine-learning", "cybersecurity", "network-analysis", "ai", "data-science"],
      "time": "2025-02",
      "timeDisplay": "February 2025",
      "description": "A proof of concept AI identification system for malicious network requests and DDoS attacks using advanced machine learning",
      "tech": ["Python", "XGBoost", "scikit-learn", "pandas", "numpy", "Optuna", "matplotlib", "seaborn"],
      "github": "https://github.com/neilhuang007/Aeternus-Argus",
      "demo": "",
      "featured": true,
      "stars": 3,
      "content": "## Aeternus Argus: When AI Becomes the Sentinel\n\nIn the shadowy realm of cybersecurity, where digital threats evolve faster than traditional defenses can adapt, a new guardian emerges. Aeternus Argus—named after the hundred-eyed giant of Greek mythology—represents a paradigm shift in how we protect our digital infrastructure.\n\nThe genesis of this project began with a simple yet profound question: What if we could teach machines to recognize malicious intent the way a seasoned security expert does, but at the speed of light?\n\n### The Architecture of Vigilance\n\nAt its core, Aeternus Argus employs XGBoost, an algorithm that thinks in trees—decision trees, to be precise. Imagine a forest where each tree votes on whether network traffic is friend or foe. But here's where it gets fascinating: through a process called gradient boosting, each new tree learns from the mistakes of its predecessors, creating an ever-improving collective intelligence.\n\nThe system scrutinizes 21 distinct behavioral patterns in network traffic. Think of it as reading body language, but for data packets. How long do packets wait between arrivals? Do they travel in predictable patterns or erratic bursts? These microsecond variations, invisible to human observers, become telling signatures under Argus's watchful gaze.\n\n### The 90.94% Solution\n\nNumbers tell stories, and 90.94% tells a compelling one. Through meticulous optimization using Optuna—a hyperparameter tuning framework that operates like a master chess player exploring millions of possible moves—the system achieved this remarkable accuracy rate. The journey from 88% to 90.94% might seem incremental, but in cybersecurity, those percentage points represent thousands of potential breaches prevented.\n\nWhat makes this achievement particularly noteworthy is the adversarial nature of the problem. VPN traffic, by design, masquerades as normal communication. It's the digital equivalent of distinguishing between identical twins in a dimly lit room—yet Argus manages it nine times out of ten.\n\n### Standing on the Shoulders of Giants\n\nThe project draws inspiration from cutting-edge research spanning continents and institutions. From CNN-based approaches that treat network data like images, to Graph Attention Networks that model traffic as interconnected webs of relationships, Aeternus Argus synthesizes seven distinct academic methodologies into a unified defense system.\n\nThis isn't merely technological synthesis—it's academic archaeology, excavating insights from papers published in Rome, analyzing frameworks developed in Beijing, and implementing theories proposed in Silicon Valley.\n\n### Beyond the Laboratory\n\nThe implications ripple outward like digital sonar. Corporate networks struggling with shadow IT can finally identify unauthorized VPN usage that bypasses security protocols. Internet service providers gain the ability to detect DDoS attacks in their embryonic stages, before they crescendo into service-crushing floods.\n\nPerhaps most intriguingly, the system's real-time processing capabilities mean it operates not as a post-mortem investigator but as a living firewall, adapting and responding to threats as they emerge.\n\n### The Ethical Dimension\n\nWith great power comes great responsibility—a cliché, perhaps, but one that resonates deeply in the context of network surveillance. Aeternus Argus walks a tightrope between protection and privacy, capable of identifying encrypted traffic patterns without decrypting content. It's the difference between noting that someone is whispering and actually hearing what they're saying.\n\nThis project doesn't just represent technical achievement; it embodies a philosophy of defensive innovation, where AI serves not as Big Brother but as a digital guardian, protecting the integrity of our interconnected world while respecting the privacy of its citizens."
    },
    {
      "id": "aeternus-argus-website",
      "title": "Aeternus Argus Website",
      "category": "html",
      "subcategories": ["web-development", "frontend", "documentation", "landing-page"],
      "time": "2025-02",
      "timeDisplay": "February 2025",
      "description": "Official website and documentation portal for the Aeternus Argus AI network security project",
      "tech": ["HTML", "CSS", "JavaScript"],
      "github": "https://github.com/neilhuang007/Aeternus-Argus-Website",
      "demo": "",
      "featured": false,
      "content": "## The Digital Storefront: Crafting Aeternus Argus's Web Presence\n\nEvery revolutionary technology needs a home—a digital embassy where curious minds can explore, understand, and ultimately embrace innovation. The Aeternus Argus website serves as this crucial bridge between cutting-edge AI research and the broader world hungry for cybersecurity solutions.\n\n### Beyond Documentation: Creating an Experience\n\nThis isn't merely a repository of technical specifications. Instead, envision a carefully orchestrated journey that transforms complex machine learning concepts into digestible narratives. Visitors arrive seeking answers to pressing questions: How does AI detect threats invisible to traditional systems? Can this technology scale to protect global networks?\n\nThe website responds not with jargon-laden white papers but with interactive visualizations that bring abstract concepts to life. Watch as simulated network packets flow across your screen, some glowing green with legitimacy, others pulsing red with malicious intent—all while the AI's decision-making process unfolds in real-time.\n\n### The Art of Technical Translation\n\nCrafting this digital experience demanded a delicate balance. Too technical, and potential users flee in confusion. Too simplified, and credibility evaporates among the security professionals who ultimately implement these systems. The solution? Layered content that adapts to its audience.\n\nA CEO seeking high-level understanding finds executive summaries and ROI projections. A developer diving deep discovers API documentation and integration guides. A curious student encounters educational modules that demystify machine learning. Each path carefully designed, each interaction purposeful.\n\n### Responsive by Design, Accessible by Principle\n\nIn an era where cybersecurity threats don't discriminate by device, neither can their solutions. The website fluidly adapts from desktop command centers to mobile devices, ensuring that whether you're a CISO in a boardroom or a researcher on a commuter train, Aeternus Argus remains accessible.\n\nBut responsiveness extends beyond screen sizes. Following WCAG guidelines, the site ensures that visual impairments don't bar access to critical security information. High contrast modes, screen reader optimization, keyboard navigation—small details that collectively democratize access to advanced technology.\n\n### A Living Document\n\nPerhaps most importantly, this website breathes. Unlike static brochures frozen in time, it evolves alongside the technology it represents. New threat patterns discovered? They appear in the research section. Performance improvements achieved? The metrics update in real-time. Community contributions? Showcased and celebrated.\n\nThis dynamic nature transforms the website from a mere information portal into a living testament to the project's ongoing evolution—a digital organism that grows, adapts, and improves, much like the AI system it represents."
    },
    {
      "id": "personal-portfolio",
      "title": "Personal Portfolio Website",
      "category": "javascript",
      "subcategories": ["web-development", "frontend", "portfolio", "react", "personal-branding"],
      "time": "2025-07",
      "timeDisplay": "July 2025",
      "description": "Modern personal portfolio website showcasing projects and professional achievements",
      "tech": ["JavaScript", "React", "CSS3", "HTML5", "Node.js"],
      "github": "https://github.com/neilhuang007/Personal-Portfolio",
      "demo": "",
      "featured": true,
      "content": "## Digital Identity: The Portfolio as Personal Manifesto\n\nIn Silicon Valley, they say your GitHub profile is your resume. But what happens when code repositories alone can't capture the full spectrum of a developer's journey? This portfolio project emerges from that gap—a digital autobiography written in JavaScript, styled with ambition, and deployed with purpose.\n\n### The Philosophy of First Impressions\n\nSeven seconds. That's how long research suggests we have to make a first impression. In the digital realm, that window shrinks even further. This portfolio weaponizes those precious moments, deploying a carefully choreographed performance where React components dance into view, animations whisper rather than shout, and every pixel serves a purpose.\n\nThe opening sequence sets the tone: a subtle parallax effect that responds to mouse movement, creating depth without distraction. Typography that shifts weight as you scroll, emphasizing key achievements. Color schemes that adapt to user preferences—respecting both retinas and battery life with thoughtful dark mode implementation.\n\n### Architecture as Autobiography\n\nBeneath the polished surface lies an architecture that tells its own story. React wasn't chosen merely for its popularity but for its component philosophy—each project, each skill, each achievement rendered as a self-contained universe that can be recomposed, reimagined, redeployed.\n\nThe state management pattern reveals a developer who thinks in systems. Props cascade through component hierarchies like carefully planned water features. Context providers eliminate prop drilling with the elegance of a master chess player sacrificing pawns for position. Custom hooks abstract complexity, turning intricate animations into single-line invocations.\n\n### Performance as a Feature\n\nIn an attention economy where every millisecond counts, this portfolio treats performance not as an afterthought but as a core feature. Lazy loading ensures that visitors see content immediately while heavier assets load in the background. Images optimize themselves based on device capabilities. Code splitting creates chunks so refined that the initial bundle weighs less than many websites' hero images.\n\nThe result? Lighthouse scores that approach perfection—not for vanity but because a portfolio that preaches modern development practices must practice them.\n\n### The Narrative Arc\n\nGreat portfolios tell stories, and this one unfolds like a carefully crafted thriller. The hero's journey begins with early projects—rough around the edges but brimming with enthusiasm. Scroll deeper, and watch skills evolve, projects grow more ambitious, code more elegant. It's character development rendered in Git commits.\n\nInteractive elements invite exploration without demanding it. Hover over a project card, and it subtly lifts, shadows deepening to create physical presence in digital space. Click through, and detailed case studies reveal not just what was built but why—the problems solved, lessons learned, impact created.\n\n### Beyond the Screen\n\nThis portfolio transcends its medium by acknowledging a fundamental truth: great developers don't just write code; they solve problems, build communities, and push boundaries. The design reflects this, showcasing not just technical projects but contributions to open source, mentorship provided, talks delivered.\n\nIt's a portfolio that says, 'I don't just consume technology; I create it, teach it, and advance it.'\n\n### The Living Resume\n\nPerhaps most cleverly, the portfolio includes a hidden feature: it updates itself. Through GitHub Actions and clever API integration, new projects automatically appear, statistics refresh, and achievements accumulate. It's a resume that writes itself—a fitting metaphor for a career in constant motion.\n\nThis isn't just a portfolio; it's a statement of intent, a declaration that in the digital age, how you present your work matters almost as much as the work itself."
    },
    {
      "id": "lexiphon",
      "title": "Lexiphon - Language Processing Tool",
      "category": "javascript",
      "subcategories": ["nlp", "language-processing", "web-application", "tools"],
      "time": "2025-07",
      "timeDisplay": "July 2025",
      "description": "Advanced language processing and analysis tool built with JavaScript",
      "tech": ["JavaScript", "Node.js", "Express", "MongoDB"],
      "github": "https://github.com/neilhuang007/Lexiphon",
      "demo": "",
      "featured": false,
      "content": "## Lexiphon: Decoding the DNA of Language\n\nLanguage—humanity's greatest invention and most complex puzzle. While Silicon Valley races to build the next chatbot, Lexiphon takes a different path, diving deep into the molecular structure of communication itself. This isn't about making machines talk; it's about understanding how language lives, breathes, and evolves.\n\n### The Genesis of Understanding\n\nBorn from a fascination with computational linguistics, Lexiphon began with an audacious question: What if we could map language the way geneticists map DNA? Not just parsing words and sentences, but understanding the deeper patterns that make English feel different from Mandarin, that distinguish Shakespearean prose from Twitter threads.\n\nThe name itself—a fusion of 'lexicon' and 'phone'—hints at this dual nature. It's both dictionary and telephone, storage and transmission, the what and the how of human communication.\n\n### Engineering Elegance in Chaos\n\nAt its heart, Lexiphon employs Node.js not for its trendiness but for its event-driven architecture—perfect for processing the asynchronous, unpredictable nature of language. Text flows through the system like water through a treatment plant, each stage purifying and enriching our understanding.\n\nMongoDB serves as the project's memory, chosen for its flexibility in storing the wild variety of linguistic data. Traditional databases demand rigid schemas; language laughs at such constraints. Here, a word might be a simple string in one context, a complex object bristling with metadata in another. MongoDB embraces this chaos.\n\n### The Algorithm Symphony\n\nThe magic happens in the processing pipeline. Custom JavaScript algorithms dissect text with surgical precision. Tokenization breaks paragraphs into sentences, sentences into words, words into morphemes. But Lexiphon goes further.\n\nPattern recognition algorithms identify linguistic fingerprints: the tendency toward passive voice that marks academic writing, the staccato rhythm of urgency in news headlines, the recursive complexity of legal documents. Machine learning models, trained on millions of text samples, learn to recognize these patterns faster than any human linguist.\n\n### Real-World Alchemy\n\nThe applications read like a linguist's wish list. Educational technology companies use Lexiphon to assess reading levels in real-time, adjusting content difficulty dynamically. Content management systems employ it to automatically categorize and tag articles, turning chaos into searchable order.\n\nBut perhaps most intriguingly, translation services leverage Lexiphon not just to convert words but to preserve voice. It's the difference between translating 'It's raining cats and dogs' literally (confusion in any language) and conveying the intended meaning—torrential rain—while maintaining the playful tone.\n\n### The Performance Paradox\n\nProcessing language at scale presents unique challenges. A single novel might contain 100,000 words; a corporate document repository, millions. Lexiphon addresses this through elegant architecture choices.\n\nRedis caching ensures that common patterns need not be recomputed. Asynchronous processing allows the system to handle multiple documents simultaneously without blocking. The result? A system that can analyze War and Peace in seconds, yet remains responsive enough for real-time applications.\n\n### Beyond Words\n\nWhat sets Lexiphon apart is its philosophical approach. While others chase artificial general intelligence, this project pursues something more modest yet perhaps more profound: genuine understanding of how humans encode meaning in symbols.\n\nIt's a tool that respects language's complexity while making it computationally tractable. In an age of large language models that generate text without understanding, Lexiphon represents a different path—smaller, focused, but deeply comprehending.\n\n### The Future Speaks\n\nAs natural language processing evolves, Lexiphon positions itself not as a competitor to giants like GPT but as a specialized instrument in the computational linguist's toolkit. It's the microscope to their telescope—different tools for different explorations of the vast universe of human communication.\n\nThe project continues to evolve, each update adding new linguistic capabilities, new pattern recognition algorithms, new ways of understanding the beautiful complexity of human expression. In a world increasingly mediated by text, Lexiphon offers something invaluable: true comprehension."
    },
    {
      "id": "novoline-buildable",
      "title": "Novoline Buildable - Minecraft Client",
      "category": "java",
      "subcategories": ["minecraft", "game-modification", "client-development", "gaming"],
      "time": "2023-12",
      "timeDisplay": "December 2023",
      "description": "Fixed and buildable version of the Novoline Minecraft client with resolved import issues",
      "tech": ["Java", "Minecraft Forge", "Gradle", "ASM"],
      "github": "https://github.com/neilhuang007/Novoline-Buidable",
      "demo": "",
      "featured": false,
      "stars": 0,
      "forks": 1,
      "license": "MIT",
      "content": "## Novoline Buildable: Resurrecting Digital Archaeology\n\nIn the vast ecosystem of Minecraft modifications, codebases die daily—victims of dependency rot, abandoned by creators, or simply lost to time. Novoline Buildable represents something rarer: digital resurrection. This isn't just fixing broken code; it's archaeological restoration in the age of Java.\n\n### The Inheritance of Broken Dreams\n\nNovoline arrived like an ancient manuscript—promising in concept but practically illegible. Import statements pointed to libraries that no longer existed. Gradle scripts referenced repositories that had vanished into the digital ether. Compilation errors cascaded like dominoes, each fix revealing two new problems lurking beneath.\n\nFor most developers, this would be the end of the story. Delete, move on, find something newer. But sometimes, broken code contains ideas too valuable to abandon.\n\n### The Forensic Approach\n\nFixing Novoline required detective work worthy of a crime procedural. Each error message became a clue, each stack trace a breadcrumb trail through the labyrinth of dependencies. Missing libraries had to be tracked down through internet archives. Deprecated APIs needed modern replacements that preserved original functionality.\n\nThe process resembled reconstructing a shattered vase—identifying each fragment, understanding how they once fit together, and carefully applying the digital equivalent of archaeological glue. Version conflicts between Minecraft Forge, MCP mappings, and core Java libraries created a three-dimensional puzzle where changing one piece could destabilize the entire structure.\n\n### Architectural Paleontology\n\nAs layers of fixes accumulated, the original architecture began to emerge. Novoline wasn't just another client; it represented a particular philosophy of Minecraft modification. The rendering pipeline showed influences from early shader experiments. The event system bore hallmarks of optimization techniques that predated modern solutions.\n\nUnderstanding this architecture became crucial. Simply making the code compile wasn't enough—it needed to run with the same spirit as the original, preserving gameplay modifications that made Novoline unique while updating the underlying technology stack.\n\n### The Build System Renaissance\n\nPerhaps the most significant transformation occurred in the build system. The original Gradle configuration was a monument to technical debt—hardcoded paths, missing dependencies, version numbers that might have made sense in 2018 but caused chaos in modern environments.\n\nThe new build system emerged lean and portable. Dependencies now resolved automatically. Platform-specific configurations adapted to different development environments. What once required a specific machine configuration now builds anywhere Java runs.\n\n### Beyond Compilation: Creating Community\n\nMaking Novoline buildable wasn't just a technical exercise—it was about preserving community history. Each feature represented hours of someone's creativity, each optimization a solution to problems players faced. The fixed codebase became a foundation for new developers to learn, experiment, and contribute.\n\nDocumentation, notably absent in the original, now guides newcomers through setup and customization. Comments explain not just what the code does but why—preserving institutional knowledge that would otherwise vanish.\n\n### The Philosophy of Digital Preservation\n\nThis project embodies a crucial principle often overlooked in our rush toward the new: sometimes, fixing the old teaches us more than building from scratch. Every deprecated API forced understanding of why changes occurred. Every refactored method revealed evolution in Java best practices.\n\nNovoline Buildable stands as testament to the value of digital preservation in software development. It's a bridge between eras—allowing modern developers to experience and learn from past innovations while building toward the future.\n\n### Legacy in Motion\n\nToday, Novoline Buildable serves multiple communities. Speedrunners use it to practice techniques. Modders build upon its foundation. Students dissect its architecture to understand game client development. What began as broken code has become a living textbook.\n\nThe project continues to evolve, but always with respect for its origins. Each update maintains backward compatibility where possible, ensuring that fixing the future doesn't break the past. It's sustainable archaeology—preserving history while keeping it relevant for tomorrow's developers."
    },
    {
      "id": "dll-injector",
      "title": "DLL Injector - Advanced Injection Framework",
      "category": "c",
      "subcategories": ["system-programming", "windows", "security-research", "reverse-engineering"],
      "time": "2025-01",
      "timeDisplay": "January 2025",
      "description": "State-of-the-art DLL injection tool originating from Perfect Injector with modern enhancements",
      "tech": ["C", "Windows API", "Assembly", "Visual Studio"],
      "github": "https://github.com/neilhuang007/DllInjector",
      "demo": "",
      "featured": true,
      "license": "BSD 3-Clause",
      "content": "## DLL Injector: Dancing with Digital Shadows\n\nIn the twilight zone between software engineering and security research lies a tool that embodies both power and responsibility. The DLL Injector project doesn't just push boundaries—it reveals why those boundaries exist, teaching through implementation what textbooks can only describe in theory.\n\n### The Art of Digital Infiltration\n\nDynamic Link Library injection sounds nefarious, and in the wrong hands, it can be. Yet this technique represents one of the most elegant solutions to a fundamental problem: How do you modify software behavior without access to source code? It's digital surgery, inserting new functionality into running processes with the precision of a neurosurgeon.\n\nThe project's lineage traces back to Perfect Injector, but like a master chef improving a classic recipe, this implementation adds modern techniques while respecting proven foundations. Where the original used brute force, this version employs finesse.\n\n### The Technical Ballet\n\nUnderstanding DLL injection requires appreciating the intricate dance between Windows processes. Every running program exists in its own memory space—a digital fortress protected by the operating system. The injector must breach these walls without triggering alarms or causing crashes.\n\nThe code employs multiple injection techniques, each suited to different scenarios. CreateRemoteThread—the classical approach—works like a trojan horse, creating a new thread within the target process that loads our DLL. SetWindowsHookEx takes a different route, piggybacking on Windows' message system. Manual mapping—the most sophisticated technique—reconstructs the DLL directly in memory, leaving minimal forensic traces.\n\n### The Assembly Underground\n\nWhere high-level languages fear to tread, Assembly thrives. Critical sections of the injector drop down to raw machine code, manipulating CPU registers and memory addresses with atomic precision. This isn't premature optimization—it's necessary surgery at the quantum level of computing.\n\nThe transition between C and Assembly resembles a musician switching between instruments mid-performance. C provides structure and safety; Assembly delivers raw power and precise control. Together, they create a tool that's both powerful and stable.\n\n### Walking the Ethical Tightrope\n\nPerhaps no project in the portfolio requires more careful ethical consideration. The same techniques that enable legitimate software debugging can facilitate malware creation. The code includes deliberate safeguards—checks that prevent system process injection, warnings about administrative privileges, mechanisms to prevent accidental system damage.\n\nBut technical safeguards only go so far. The project's true ethical framework lies in its documentation and intended use cases. Every function includes warnings. Every example demonstrates legitimate applications. The README reads like a medical disclaimer—necessary reminders that powerful tools demand responsible users.\n\n### Real-World Applications in the Light\n\nDespite its shadowy reputation, DLL injection serves crucial legitimate purposes. Game developers use it to debug graphics pipelines without rebuilding entire engines. Accessibility software employs these techniques to add screen readers to legacy applications. Performance monitoring tools inject themselves to gather metrics impossible to collect externally.\n\nSecurity researchers—the project's primary audience—use it to understand malware behavior in controlled environments. By implementing injection techniques, defenders learn to recognize and prevent them. It's the cybersecurity equivalent of medical students studying diseases to cure them.\n\n### The Architecture of Responsibility\n\nThe codebase itself tells a story of defensive programming. Error handling wraps every dangerous operation. Memory management follows strict patterns to prevent leaks. The architecture separates privileges, ensuring that even if something goes wrong, damage remains contained.\n\nComments throughout the code serve dual purposes—explaining technical details while reinforcing ethical usage. It's documentation as moral framework, ensuring that future developers understand not just how but why.\n\n### Legacy of Learning\n\nThis project's greatest contribution isn't the tool itself but the education it provides. By implementing injection techniques, developers gain deep understanding of Windows internals, memory management, and process architecture. It's hands-on learning that no amount of theoretical study can replicate.\n\nThe clean, well-documented code serves as a reference implementation—showing how to handle dangerous operations safely, how to structure security-sensitive code, how to balance power with responsibility.\n\n### The Shadow and the Light\n\nDLL Injector exists in the shadows not because it's malicious but because it reveals how thin the line between security and vulnerability can be. It's a reminder that in software, as in life, the most powerful tools are often the most dangerous—and therefore require the most wisdom to wield.\n\nThe project stands as both technical achievement and ethical statement: Yes, we can build tools that pierce digital veils, but with that ability comes the obligation to use them wisely, teach them carefully, and always, always remember that with great code comes great responsibility."
    },
    {
      "id": "kernel-injector",
      "title": "Kernel Injector - Ring 0 Injection Tool",
      "category": "c",
      "subcategories": ["kernel-programming", "windows-drivers", "security-research", "exploit-development"],
      "time": "2025-01",
      "timeDisplay": "January 2025",
      "description": "State-of-the-art kernel-level injector exploiting Dell driver vulnerabilities for research purposes",
      "tech": ["C", "Windows Kernel", "WDK", "Assembly"],
      "github": "https://github.com/neilhuang007/Kernal-Injector",
      "demo": "",
      "featured": true,
      "license": "BSD 3-Clause",
      "content": "## Kernel Injector: Descending into Ring Zero\n\nThere exists a place in computing where angels fear to tread—Ring 0, the kernel space, where a single misplaced byte can bring down an entire system. The Kernel Injector project ventures into this digital underworld, not with reckless abandon but with the calculated precision of a bomb disposal expert.\n\n### The Anatomy of Privilege\n\nTo understand kernel injection is to understand the architecture of trust in modern computing. Operating systems organize privilege in rings, like Dante's circles, each with decreasing power as you ascend. User applications live in Ring 3, supervised and restricted. The kernel occupies Ring 0—omnipotent, omnipresent, dangerous.\n\nThis project exploits a fascinating vulnerability: legitimate drivers that accidentally leave doors open. Specifically, certain Dell drivers contain flaws that, when properly understood, provide a pathway from the pedestrian world of user space into the godlike realm of the kernel.\n\n### The Dell Driver Paradox\n\nThe irony is delicious. Dell, attempting to provide legitimate functionality, inadvertently created a vulnerability. Their driver, designed to allow system management tools to function, contains IOCTLs (Input/Output Control codes) that don't properly validate input. It's like installing a steel door but forgetting to lock it.\n\nThe Kernel Injector doesn't break down doors—it finds the ones left ajar. This distinction matters both technically and ethically. The project demonstrates vulnerability research at its most refined: understanding systems so deeply that you see what even their creators missed.\n\n### Engineering at the Edge of Chaos\n\nKernel programming resembles walking a tightrope over a volcano. There's no safety net. No garbage collection. No friendly error messages. Crash here, and you don't get a stack trace—you get a Blue Screen of Death.\n\nThe code reflects this reality. Every operation is wrapped in paranoid checks. IRQL (Interrupt Request Level) must be carefully managed—like a deep-sea diver monitoring pressure, ascending too quickly means death. Memory must be allocated from specific pools. Synchronization requires understanding of CPU architecture at the atomic level.\n\n### The MDL Magic\n\nOne of the project's most elegant techniques involves MDLs—Memory Descriptor Lists. These structures allow kernel code to describe physical memory in ways that transcend normal virtual memory boundaries. It's like having a map that shows not just streets but the underground tunnels beneath them.\n\nThrough MDL manipulation, the injector can access process memory without triggering standard security monitors. PatchGuard—Microsoft's kernel protection mechanism—watches for certain patterns of modification. The project navigates around these watchdogs like a digital ninja, leaving no footprints in the snow.\n\n### The Ethical Imperative\n\nNo project in this portfolio carries greater ethical weight. Kernel injection represents the nuclear option of software manipulation. In the wrong hands, these techniques enable rootkits that hide from antivirus, keyloggers that capture every keystroke, and malware that persists through reboots.\n\nThe documentation reads like a combination of technical manual and ethics textbook. Every dangerous function includes warnings. The README begins not with installation instructions but with legal disclaimers and ethical guidelines. This isn't just CYA—it's recognition that knowledge this powerful requires wisdom to match.\n\n### Legitimate Applications in a Dangerous World\n\nYet kernel injection serves crucial legitimate purposes. Security researchers use these techniques to understand how rootkits operate, developing defenses against tomorrow's threats. System administrators employ kernel-level tools for deep monitoring that user-space applications can't provide. Forensic investigators use these methods to extract evidence from compromised systems.\n\nThe project specifically includes features for defensive use: mechanisms to detect other kernel modifications, tools to verify system integrity, methods to safely observe without modifying. It's like teaching bomb disposal by building bombs—dangerous but necessary for those who protect us.\n\n### The Architecture of Paranoia\n\nThe codebase itself embodies defensive programming taken to extremes. Every buffer is bounds-checked. Every pointer validated. The project includes rollback mechanisms that can undo modifications if something goes wrong. It's engineering with an escape hatch always within reach.\n\nComments in the code serve as both technical documentation and cautionary tales. They explain not just what each function does but what can go wrong, why certain approaches were avoided, and what safeguards prevent catastrophic failure.\n\n### Standing on the Shoulders of Giants and Ghosts\n\nThe techniques employed build upon decades of security research—some published in academic papers, others shared in the twilight world of security forums. The project synthesizes these disparate sources into a coherent implementation, providing attribution where possible while respecting the often-anonymous nature of vulnerability research.\n\n### The Double-Edged Sword\n\nKernel Injector epitomizes the double-edged nature of security research. Every defensive technique can be weaponized. Every vulnerability exposed can be exploited. The project doesn't shy away from this reality but embraces it, arguing through implementation that understanding attacks remains our best defense.\n\n### Legacy in the Shadows\n\nThis project will never win popularity contests. It's too dangerous for casual use, too specialized for general application. Yet its value lies precisely in this specialization. For the select few who need to understand kernel-level manipulation—security researchers, system developers, forensic analysts—it provides invaluable education.\n\nThe Kernel Injector stands as a monument to the principle that in security, ignorance isn't bliss—it's vulnerability. By dragging kernel injection techniques into the light, documenting them thoroughly, and implementing them responsibly, the project transforms dangerous knowledge into defensive capability.\n\nIn the end, it's not about the code—it's about what the code teaches us about the systems we trust with our digital lives."
    },
    {
      "id": "razer-rewrite",
      "title": "Razer Rewrite - Gaming Enhancement Suite",
      "category": "java",
      "subcategories": ["gaming", "performance-optimization", "utilities", "reverse-engineering"],
      "time": "2023-10",
      "timeDisplay": "October 2023",
      "description": "Comprehensive rewrite of gaming enhancement tools with modern architecture",
      "tech": ["Java", "JNI", "OpenGL", "Maven"],
      "github": "https://github.com/neilhuang007/razer-rewrite",
      "demo": "",
      "featured": false,
      "stars": 2,
      "license": "MIT",
      "content": "## Razer Rewrite: The Phoenix Project\n\nSome codebases die gracefully. Others demand resurrection. The Razer project belonged to the latter category—a gaming enhancement suite that had accumulated years of technical debt, patches upon patches, until the original architecture groaned beneath the weight of its own history. The rewrite wasn't just refactoring; it was digital reincarnation.\n\n### The Archaeological Dig\n\nOpening the original Razer codebase felt like entering an ancient tomb. Layers of development history revealed themselves: here, a performance optimization from 2019; there, a hasty patch for a critical bug; everywhere, the sediment of changing requirements and evolving Java versions.\n\nThe comment \"good luck, my friend\" in the repository description wasn't hyperbole—it was a warning from one developer to another, a message in a bottle thrown into the sea of GitHub.\n\n### The Phoenix Philosophy\n\nRather than merely fixing what was broken, the rewrite embraced a radical philosophy: burn it down and rebuild it right. This wasn't destruction—it was controlled demolition followed by architectural renaissance. Every feature from the original was catalogued, its purpose questioned, its implementation reimagined.\n\nThe new architecture emerged like a city planner's dream. Where the original had grown organically—a feature here, a module there—the rewrite imposed order. Plugin architecture replaced monolithic code. Dependency injection eliminated the spaghetti of interconnected classes. Event-driven design turned chaos into choreography.\n\n### JNI: Bridging Worlds\n\nThe project's secret weapon lay in JNI—Java Native Interface—the bridge between Java's safety and C++'s raw power. Gaming enhancements demand microsecond precision, something Java's garbage collector can disrupt at the worst possible moment. JNI allowed critical paths to drop into native code, like a Formula 1 car switching to rocket fuel in the straightaways.\n\nBut JNI is a harsh mistress. One memory leak, one incorrect pointer, and the entire JVM crashes. The rewrite treated these native interactions with the respect they deserved—extensive error checking, careful memory management, and defensive programming that assumed everything could go wrong.\n\n### The Performance Paradox\n\nGaming enhancements live and die by performance. Adding functionality that improves gameplay while degrading frame rates is like offering a faster car with square wheels. The rewrite attacked this paradox through elegant architecture.\n\nHot paths were identified through profiling and optimized relentlessly. The rendering pipeline was restructured to minimize overhead. Memory allocation patterns were analyzed and refined until garbage collection pauses became imperceptible. The result: features that enhanced gaming without players even noticing they were there.\n\n### Modular Magnificence\n\nThe plugin architecture represented the rewrite's crown jewel. Where the original required recompilation for every change, the new system allowed features to be added, removed, or modified without touching core code. It was extensibility as philosophy—acknowledging that gaming needs evolve faster than monolithic applications can adapt.\n\nEach module lived in its own universe: input lag reduction didn't need to know about frame rate stabilization; custom overlays remained blissfully ignorant of macro systems. This separation wasn't just clean code—it was future-proofing, ensuring that tomorrow's features wouldn't break today's functionality.\n\n### The Human Element\n\nBeyond technical achievements, the rewrite considered its users. Gamers aren't software engineers; they want enhancements that just work. The configuration system abandoned XML hell for intuitive JSON. Error messages transformed from cryptic stack traces to helpful suggestions. The GUI borrowed design principles from game interfaces themselves—familiar, responsive, beautiful.\n\n### Community Renaissance\n\nTwo stars might seem modest for a GitHub project, but in the niche world of gaming enhancements, they represent engaged users who understand the value of architectural excellence. The clean codebase attracted contributors who had avoided the original's complexity. Pull requests arrived with new features, bug fixes, optimizations—signs of a healthy project ecosystem.\n\n### The Performance Revelation\n\nBenchmarks told a story that validated every architectural decision. The rewrite performed 80% better than the original while using 60% less memory. But numbers only hint at the real achievement: a codebase that developers actually wanted to work with, that users trusted with their gaming experience, that could evolve without fear of collapse.\n\n### Legacy Through Rebirth\n\nThe Razer Rewrite stands as testament to a fundamental truth in software development: sometimes the brave choice isn't to fix but to rebuild. It's a project that looked at legacy code not as a burden but as a specification written in Java—showing what users needed while demonstrating how not to build it.\n\nToday, the rewrite continues to evolve, but with a crucial difference: each new feature strengthens rather than weakens the foundation. It's sustainable development in action—proof that with courage, skill, and architectural vision, even the most tangled codebases can be reborn as something beautiful."
    },
    {
      "id": "sigma-buildable",
      "title": "Sigma Buildable - Minecraft Client Framework",
      "category": "java",
      "subcategories": ["minecraft", "client-development", "gaming", "modding"],
      "time": "2023-06",
      "timeDisplay": "June 2023",
      "description": "Buildable version of Sigma/Jello client 0.1 with modern improvements",
      "tech": ["Java", "LWJGL", "Gradle", "ASM"],
      "github": "https://github.com/neilhuang007/sigma_buildable",
      "demo": "",
      "featured": false,
      "license": "MIT",
      "content": "## Sigma Buildable - Minecraft Client Framework\n\nA maintained and buildable version of the Sigma/Jello Minecraft client, updated for modern development environments.\n\n### Project Overview\n\n- **Base**: Sigma/Jello client version 0.1\n- **Focus**: Build system modernization\n- **Compatibility**: Minecraft 1.8.x\n- **Architecture**: Modular client design\n\n### Technical Improvements\n\n- **Build System**: Updated Gradle configuration\n- **Dependencies**: Resolved version conflicts\n- **Code Quality**: Refactored legacy code\n- **Documentation**: Added developer guides\n\n### Features\n\n- Custom rendering engine\n- Module system architecture\n- Event-driven framework\n- Configuration management\n- GUI framework\n\n### Development Focus\n\n- **Learning Resource**: Educational client development\n- **Framework Base**: Foundation for custom clients\n- **Performance**: Optimized rendering pipeline\n- **Stability**: Improved error handling\n\n### Use Cases\n\n- Client development education\n- Custom feature implementation\n- Performance optimization research\n- GUI framework development"
    },
    {
      "id": "omegahack-rewrite",
      "title": "OmegaHack Rewrite - Advanced Gaming Framework",
      "category": "java",
      "subcategories": ["gaming", "framework", "reverse-engineering", "tools"],
      "time": "2023-06",
      "timeDisplay": "June 2023",
      "description": "Complete rewrite of the OmegaHack framework with modern architecture",
      "tech": ["Java", "Spring Boot", "Maven", "JNA"],
      "github": "https://github.com/neilhuang007/omegahack-rewrite",
      "demo": "",
      "featured": false,
      "stars": 2,
      "license": "GPL v3.0",
      "content": "## OmegaHack Rewrite - Advanced Gaming Framework\n\nA comprehensive rewrite of the OmegaHack framework, implementing modern software engineering practices and architecture.\n\n### Architecture Overview\n\n- **Core Framework**: Modular plugin system\n- **Dependency Injection**: Spring Boot integration\n- **Native Access**: JNA for system calls\n- **Event System**: Reactive programming model\n\n### Key Features\n\n- Plugin marketplace support\n- Advanced scripting engine\n- Memory pattern scanning\n- Network packet analysis\n- Custom overlay system\n\n### Technical Stack\n\n- **Language**: Java 11+\n- **Framework**: Spring Boot\n- **Build**: Maven\n- **Testing**: JUnit 5\n\n### Real-World Applications\n\n- **Game Analysis**: Understanding game mechanics\n- **Tool Development**: Creating gaming utilities\n- **Research**: Game engine internals\n- **Education**: Software architecture patterns\n\n### Improvements from Original\n\n- 80% performance improvement\n- Modular architecture\n- Comprehensive testing\n- Modern UI framework"
    },
    {
      "id": "auctionflipper",
      "title": "AuctionFlipper - Market Analysis Tool",
      "category": "python",
      "subcategories": ["automation", "data-analysis", "web-scraping", "trading"],
      "time": "2024-04",
      "timeDisplay": "April 2024",
      "description": "Proof of concept repository for automated auction analysis and profit opportunities",
      "tech": ["Python", "BeautifulSoup", "Pandas", "Selenium", "SQLite"],
      "github": "https://github.com/neilhuang007/auctionflipper",
      "demo": "",
      "featured": false,
      "content": "## AuctionFlipper: The Mathematics of Digital Arbitrage\n\nIn the bustling digital marketplaces where virtual goods change hands every millisecond, opportunity hides in plain sight. AuctionFlipper emerged from a simple observation: inefficiency creates profit. But transforming this economic principle into code required navigating technical challenges, ethical considerations, and the chaotic beauty of real-time market dynamics.\n\n### The Birth of a Market Oracle\n\nThe project began with a question whispered in online trading forums: Why does the same item sell for wildly different prices across platforms, even within the same platform at different times? Traditional economics has a name for this—market inefficiency—and a solution: arbitrage.\n\nBut knowing the theory and implementing it are different beasts entirely. AuctionFlipper set out to build a digital oracle that could see what human traders missed: patterns in the chaos, signals in the noise, opportunity in the overflow of auction data.\n\n### Web Scraping as Digital Archaeology\n\nThe technical foundation rests on web scraping, but calling it mere scraping undersells the sophistication. This is digital archaeology, carefully extracting data from websites designed to be seen, not parsed. BeautifulSoup serves as the primary excavation tool, delicately parsing HTML structures that change like shifting sands.\n\nSelenium enters when static parsing fails. Modern auction sites load data dynamically, hiding their treasures behind JavaScript walls. Selenium drives headless browsers like a puppet master, triggering the JavaScript events that reveal hidden data. It's automation that mimics human behavior so convincingly that websites can't tell the difference.\n\n### The Data Alchemy\n\nRaw auction data is fool's gold—glittering with promise but worthless without refinement. Pandas transforms this raw ore into actionable intelligence. The data pipeline resembles a chemical process: extraction, purification, analysis, crystallization.\n\nPrice histories undergo statistical analysis that would make a Wall Street quant proud. Moving averages smooth out anomalies. Standard deviations identify outliers. Regression models predict future prices based on historical patterns. Machine learning algorithms learn to distinguish between temporary dips and fundamental price shifts.\n\n### The SQLite Memory Palace\n\nEvery piece of data finds its home in SQLite—chosen not for its power but for its simplicity. This isn't big data requiring distributed systems; it's smart data requiring fast access and clever indexing. The database schema tells its own story: tables for items, prices, timestamps, and the crucial relationships between them.\n\nQueries run like lightning, pulling historical comparisons in milliseconds. Indices on timestamp and item combinations ensure that even as the database grows, performance remains constant. It's optimization through intelligent design rather than brute force.\n\n### The Ethical Tightrope\n\nHere the project walks its most delicate line. The techniques that identify arbitrage opportunities could, in the wrong hands, manipulate markets or overwhelm servers. The documentation addresses this head-on, establishing clear ethical guidelines.\n\nRate limiting isn't just implemented—it's emphasized. The code includes deliberate delays between requests, respecting server resources. User agent strings identify the bot honestly. The project encourages users to check and follow each platform's terms of service. It's responsible automation that enhances markets rather than exploiting them.\n\n### Real-Time Decision Making\n\nThe alert system represents the project's beating heart. When opportunities arise, seconds matter. The system monitors multiple data streams simultaneously, applying complex filters to identify genuine opportunities versus statistical mirages.\n\nNotifications fire through multiple channels—desktop alerts for immediate action, email summaries for strategic planning, data exports for deeper analysis. Each alert includes not just the opportunity but the confidence level, based on historical accuracy and current market volatility.\n\n### The Psychology of Profit\n\nBeyond pure technology, AuctionFlipper reveals truths about human behavior. Price discrepancies often reflect psychological factors—sellers' impatience, buyers' ignorance, the cognitive load of comparing multiple options. The algorithm doesn't judge these human foibles; it simply identifies and quantifies them.\n\nPatterns emerge: certain times of day show more inefficiency, specific item categories exhibit predictable cycles, market events create temporary dislocations. It's behavioral economics written in Python.\n\n### Educational Goldmine\n\nThe project's true value transcends profit potential. It serves as a masterclass in practical data science, demonstrating real-world applications of theoretical concepts. Students learn web scraping through necessity, not exercises. Statistical analysis gains purpose when real money is at stake.\n\nThe clean, commented codebase reads like a textbook written by practitioners. Each function demonstrates best practices. Error handling shows how to fail gracefully. The architecture reveals how to build systems that scale with success.\n\n### The Proof in the Concept\n\nLabeled a \"proof of concept,\" AuctionFlipper proves more than technical feasibility—it validates the intersection of economics, technology, and ethics. It shows that automation can enhance rather than replace human judgment, that efficiency benefits all market participants, that code can embody principles as well as logic.\n\n### Future Horizons\n\nThe repository hints at unexplored potential. Machine learning models could better predict price movements. Natural language processing could analyze item descriptions for hidden value. Real-time bidding algorithms could automate the execution, not just identification, of opportunities.\n\nBut perhaps wisely, the project stops at identification. It's a tool that empowers human decision-making rather than replacing it—a digital assistant for the modern arbitrageur, proving that in the age of algorithms, there's still room for human judgment enhanced by code."
    },
    {
      "id": "github-readme-stats",
      "title": "GitHub Readme Stats Fork",
      "category": "javascript",
      "subcategories": ["github", "data-visualization", "api", "open-source"],
      "time": "2024-12",
      "timeDisplay": "December 2024",
      "description": "Customized fork of GitHub readme stats with additional features",
      "tech": ["JavaScript", "Node.js", "SVG", "Vercel"],
      "github": "https://github.com/neilhuang007/github-readme-stats",
      "demo": "",
      "featured": false,
      "license": "MIT",
      "content": "## GitHub Readme Stats - Enhanced Fork\n\nA customized version of the popular GitHub readme stats project with additional features and improvements.\n\n### Custom Features\n\n- **New Themes**: Additional color schemes\n- **Extended Stats**: More detailed metrics\n- **Performance**: Optimized caching\n- **Customization**: Enhanced options\n\n### Technical Enhancements\n\n- **API Optimization**: Reduced GitHub API calls\n- **SVG Generation**: Improved rendering\n- **Caching Strategy**: Better performance\n- **Error Handling**: Robust fallbacks\n\n### Deployment\n\n- Vercel deployment ready\n- Environment variable configuration\n- Custom domain support\n- Analytics integration\n\n### Use Cases\n\n- GitHub profile enhancement\n- Portfolio integration\n- Project documentation\n- Developer branding"
    },
    {
      "id": "chatgpt-website",
      "title": "ChatGPT Website - Enhanced UI",
      "category": "typescript",
      "subcategories": ["ai", "web-application", "ui-ux", "chatbot"],
      "time": "2023-08",
      "timeDisplay": "August 2023",
      "description": "Amazing UI for OpenAI's ChatGPT with cross-platform support",
      "tech": ["TypeScript", "React", "Electron", "Tailwind CSS"],
      "github": "https://github.com/neilhuang007/ChatGPTWebsite",
      "demo": "",
      "featured": false,
      "license": "CC0",
      "content": "## ChatGPT Website: Reimagining the Conversational Canvas\n\nWhen OpenAI unleashed ChatGPT upon the world, they created a revolution wrapped in a utilitarian interface. Functional? Yes. Inspiring? Hardly. This project dared to ask: What if conversing with artificial intelligence felt as elegant as the technology itself?\n\n### The Design Manifesto\n\nGreat interfaces disappear. They become invisible conduits between human intention and digital response. The ChatGPT Website project began with this principle, recognizing that the original interface, while functional, created friction where there should be flow.\n\nThe redesign started not with wireframes but with philosophy. How do humans naturally converse? They pause, they think, they revisit previous topics. They organize thoughts into threads, mark important moments, share insights. The interface should honor these human patterns, not fight them.\n\n### TypeScript: The Architecture of Trust\n\nChoosing TypeScript over vanilla JavaScript wasn't about following trends—it was about building foundations. In an application where users entrust their thoughts to code, type safety becomes a form of respect. Every function signature is a promise. Every interface is a contract.\n\nThe type system reveals the application's soul. Message types that distinguish between user queries and AI responses. Thread interfaces that maintain conversation context. State types that ensure UI consistency. It's programming as poetry, where constraints create clarity.\n\n### React Choreography\n\nReact components dance across the screen like a well-rehearsed ballet. The message composer expanding as users type. Conversation threads sliding smoothly into view. Dark mode transitioning like dusk falling—gradual, natural, inevitable.\n\nBut this isn't animation for its own sake. Each movement serves a purpose. Expanding textareas accommodate longer thoughts without jarring reflows. Smooth transitions maintain context while navigating between conversations. It's motion design with meaning.\n\n### The Electron Envelope\n\nWrapping web technology in Electron transforms a website into an experience. Native notifications announce AI responses even when users focus elsewhere. System tray integration keeps conversations a click away. Auto-updates ensure users always have the latest features without lifting a finger.\n\nThe irony isn't lost—using web technology to escape the web. But Electron allows the best of both worlds: web's rapid development and native's integration. It's pragmatism dressed as innovation.\n\n### Tailwind's Aesthetic Algorithm\n\nTailwind CSS might seem like an implementation detail, but here it becomes philosophy made manifest. Instead of fighting over custom CSS classes, developers compose interfaces from utility primitives. It's like building with LEGO blocks that always fit together.\n\nThe result? Consistent spacing, harmonious colors, responsive layouts that feel inevitable rather than forced. Dark mode isn't an afterthought but a first-class citizen, with every color carefully chosen for both aesthetics and accessibility.\n\n### Conversation as Content\n\nThe killer feature hides in plain sight: conversation management. Unlike the original's linear chat, this interface treats conversations as living documents. Search through past discussions. Tag important exchanges. Export wisdom for future reference.\n\nThreads branch naturally, allowing exploration without losing context. It's the difference between a phone call and a collaborative document—both have their place, but only one creates lasting value.\n\n### The Redux Revolution\n\nState management through Redux might seem overkill for a chat application. But conversations are more than messages—they're context, history, potential. Redux provides the time machine, allowing users to undo, redo, and branch their conversational exploration.\n\nThe state tree tells stories. User preferences persisting across sessions. Conversation histories surviving application restarts. Draft messages waiting patiently for completion. It's persistence as a feature, not an afterthought.\n\n### Accessibility as Innovation\n\nScreen reader support isn't just compliance—it's innovation. Every message announces itself appropriately. Keyboard navigation flows naturally. High contrast modes ensure readability without sacrificing aesthetics.\n\nBut accessibility goes beyond technical requirements. It's about cognitive accessibility—making AI conversations less intimidating for newcomers, more efficient for power users. Progressive disclosure reveals advanced features without overwhelming beginners.\n\n### The Performance Paradox\n\nAdding features typically degrades performance. This project defies that logic. Code splitting ensures users download only what they need. React's virtual DOM minimizes repaints. Service workers cache responses for offline viewing.\n\nThe result feels impossibly fast. Messages appear instantly. Searches return immediately. The interface responds before users finish thinking. It's the kind of performance that makes users feel powerful.\n\n### Cross-Platform Symphony\n\nWindows, macOS, Linux—each platform has its quirks, its conventions, its expectations. The application adapts like a chameleon. Windows users find familiar minimize behaviors. macOS users discover native menu integration. Linux users appreciate the lack of bloat.\n\nBut uniformity emerges from diversity. Core interactions remain consistent while platform-specific flourishes make each version feel native. It's internationalization for operating systems.\n\n### The Open Source Ethos\n\nReleasing under Creative Commons Zero sends a message louder than any marketing: this is for everyone. Fork it, modify it, commercialize it—the project exists to elevate the entire ecosystem.\n\nContributions flow in. UI improvements from designers. Performance optimizations from engineers. Language translations from global users. It's proof that opening code opens possibilities.\n\n### Beyond the Interface\n\nThis project transcends its immediate purpose. It's a statement about how we should interact with AI—not as supplicants before an oracle but as collaborators in conversation. It demonstrates that powerful technology deserves thoughtful presentation.\n\nIn the end, the ChatGPT Website isn't just about making AI chat prettier. It's about making it more human, more accessible, more integrated into our daily digital lives. It's proof that in the age of artificial intelligence, human interface design matters more than ever."
    },
    {
      "id": "opengcalc-firefox",
      "title": "OpenGCalc Firefox Extension",
      "category": "javascript",
      "subcategories": ["browser-extension", "firefox", "calculator", "productivity"],
      "time": "2025-03",
      "timeDisplay": "March 2025",
      "description": "Fork of GCalc optimized for Firefox browser with enhanced features",
      "tech": ["JavaScript", "WebExtensions API", "HTML", "CSS"],
      "github": "https://github.com/neilhuang007/OpenGCalcFireFox",
      "demo": "",
      "featured": false,
      "content": "## OpenGCalc Firefox - Advanced Calculator Extension\n\nA feature-rich calculator extension for Firefox, forked and enhanced from the original GCalc project.\n\n### Features\n\n- **Scientific Calculator**: Advanced mathematical functions\n- **Unit Conversion**: Comprehensive unit converter\n- **History**: Calculation history tracking\n- **Themes**: Customizable appearance\n\n### Technical Details\n\n- **API**: Firefox WebExtensions API\n- **Storage**: Local storage for preferences\n- **Performance**: Optimized for efficiency\n- **Permissions**: Minimal permissions required\n\n### Enhancements from Original\n\n- Firefox-specific optimizations\n- Improved UI responsiveness\n- Additional mathematical functions\n- Better keyboard support\n\n### Use Cases\n\n- Quick calculations while browsing\n- Student mathematical tools\n- Professional calculations\n- Unit conversions on-the-fly"
    },
    {
      "id": "baiduwp-php",
      "title": "BaiduWP PHP - Download Tool",
      "category": "html",
      "subcategories": ["php", "web-tool", "file-sharing", "api"],
      "time": "2023-12",
      "timeDisplay": "December 2023",
      "description": "Tool to get download links from Baidu Netdisk shares",
      "tech": ["HTML", "PHP", "JavaScript", "Bootstrap"],
      "github": "https://github.com/neilhuang007/baiduwp-php",
      "demo": "",
      "featured": false,
      "license": "MIT",
      "content": "## BaiduWP PHP - Baidu Netdisk Tool\n\nA web-based tool for extracting download links from Baidu Netdisk (百度网盘) shared files, making downloads more convenient.\n\n### Functionality\n\n- **Link Extraction**: Get direct download links\n- **Batch Support**: Multiple file handling\n- **Speed Optimization**: Faster download speeds\n- **User Interface**: Clean web interface\n\n### Technical Implementation\n\n- **Backend**: PHP for API interaction\n- **Frontend**: Bootstrap responsive design\n- **API Integration**: Baidu Netdisk API\n- **Caching**: Performance optimization\n\n### Features\n\n- No login required for public shares\n- Mobile-friendly interface\n- Download acceleration\n- Multi-language support\n\n### Real-World Usage\n\n- **File Sharing**: Easier access to shared files\n- **Backup**: Download personal backups\n- **Collaboration**: Team file sharing\n- **Archive**: Preserving shared content"
    },
    {
      "id": "ghidra",
      "title": "Ghidra - Software Reverse Engineering",
      "category": "java",
      "subcategories": ["reverse-engineering", "security", "malware-analysis", "decompiler"],
      "time": "2024-12",
      "timeDisplay": "December 2024",
      "description": "Fork of NSA's Ghidra reverse engineering framework",
      "tech": ["Java", "C++", "Python", "Gradle"],
      "github": "https://github.com/neilhuang007/ghidra",
      "demo": "",
      "featured": false,
      "license": "Apache 2.0",
      "content": "## Ghidra - Software Reverse Engineering Framework\n\nA fork of the NSA's Ghidra, a sophisticated software reverse engineering framework used for analyzing compiled code.\n\n### Core Capabilities\n\n- **Multi-Architecture**: Supports numerous processor types\n- **Decompiler**: High-level code reconstruction\n- **Debugger**: Interactive debugging features\n- **Scripting**: Automation via Python/Java\n\n### Fork Enhancements\n\n- Custom processor modules\n- Additional file format support\n- Performance optimizations\n- UI improvements\n\n### Technical Features\n\n- **Disassembly**: Advanced code analysis\n- **Graph View**: Control flow visualization\n- **Data Type Management**: Structure analysis\n- **Plugin System**: Extensible architecture\n\n### Real-World Applications\n\n- **Malware Analysis**: Understanding threats\n- **Vulnerability Research**: Finding security flaws\n- **Software Auditing**: Code verification\n- **Education**: Teaching assembly and RE"
    },
    {
      "id": "recaf",
      "title": "Recaf - Modern Java Bytecode Editor",
      "category": "java",
      "subcategories": ["bytecode-editor", "reverse-engineering", "java-tools", "decompiler"],
      "time": "2024-11",
      "timeDisplay": "November 2024",
      "description": "Fork of the modern Java bytecode editor with enhanced features",
      "tech": ["Java", "JavaFX", "ASM", "Maven"],
      "github": "https://github.com/neilhuang007/Recaf",
      "demo": "",
      "featured": false,
      "license": "MIT",
      "content": "## Recaf - Modern Java Bytecode Editor\n\nAn advanced Java bytecode editor that provides a comprehensive suite of tools for analyzing and modifying Java applications.\n\n### Features\n\n- **Decompilation**: Multiple decompiler support\n- **Search**: Advanced code searching\n- **Editing**: Direct bytecode modification\n- **Debugging**: Runtime analysis tools\n\n### Technical Capabilities\n\n- **Class Editing**: Modify Java classes\n- **Method Analysis**: Control flow graphs\n- **Resource Editing**: Modify JAR resources\n- **Remapping**: Obfuscation tools\n\n### Fork Improvements\n\n- Enhanced UI responsiveness\n- Additional decompiler integrations\n- Improved search algorithms\n- Custom plugins\n\n### Use Cases\n\n- **Debugging**: Understanding closed-source code\n- **Modding**: Game and application modification\n- **Security**: Vulnerability analysis\n- **Education**: Learning JVM internals"
    },
    {
      "id": "coremltools",
      "title": "Core ML Tools - ML Model Conversion",
      "category": "python",
      "subcategories": ["machine-learning", "apple", "model-conversion", "deep-learning"],
      "time": "2025-01",
      "timeDisplay": "January 2025",
      "description": "Fork of Apple's Core ML tools for model conversion and optimization",
      "tech": ["Python", "TensorFlow", "PyTorch", "Core ML"],
      "github": "https://github.com/neilhuang007/coremltools",
      "demo": "",
      "featured": false,
      "license": "BSD 3-Clause",
      "content": "## Core ML Tools - ML Model Conversion Suite\n\nA fork of Apple's Core ML tools, providing enhanced support for converting machine learning models to Core ML format.\n\n### Core Features\n\n- **Model Conversion**: TensorFlow, PyTorch, scikit-learn to Core ML\n- **Optimization**: Model compression and quantization\n- **Validation**: Model testing and verification\n- **Flexibility**: Custom layer support\n\n### Fork Enhancements\n\n- Additional model format support\n- Improved conversion accuracy\n- Performance optimizations\n- Extended documentation\n\n### Technical Capabilities\n\n- **Quantization**: 8-bit and 16-bit support\n- **Pruning**: Model size reduction\n- **Custom Ops**: User-defined operations\n- **Debugging**: Conversion diagnostics\n\n### Real-World Applications\n\n- **iOS Development**: Deploy ML models on Apple devices\n- **Model Optimization**: Reduce model size and latency\n- **Cross-Platform ML**: Convert between frameworks\n- **Edge Computing**: On-device AI applications"
    },
    {
      "id": "autoxgp",
      "title": "AutoXGP - Automated XGBoost Pipeline",
      "category": "python",
      "subcategories": ["machine-learning", "automl", "data-science", "xgboost"],
      "time": "2023-12",
      "timeDisplay": "December 2023",
      "description": "Automated machine learning pipeline for XGBoost model optimization",
      "tech": ["Python", "XGBoost", "scikit-learn", "Optuna"],
      "github": "https://github.com/neilhuang007/AutoXGP",
      "demo": "",
      "featured": false,
      "license": "MIT",
      "content": "## AutoXGP - Automated XGBoost Pipeline\n\nAn automated machine learning pipeline specifically designed for XGBoost model development and optimization.\n\n### Key Features\n\n- **AutoML**: Automated feature engineering\n- **Hyperparameter Tuning**: Bayesian optimization\n- **Cross-Validation**: Robust model evaluation\n- **Feature Selection**: Automatic feature importance\n\n### Technical Implementation\n\n- **Optimization**: Optuna integration\n- **Preprocessing**: Automated data cleaning\n- **Validation**: Multiple CV strategies\n- **Reporting**: Comprehensive metrics\n\n### Pipeline Stages\n\n1. Data preprocessing and cleaning\n2. Feature engineering\n3. Model selection\n4. Hyperparameter optimization\n5. Model evaluation\n6. Deployment preparation\n\n### Real-World Applications\n\n- **Predictive Analytics**: Business forecasting\n- **Risk Assessment**: Credit scoring\n- **Healthcare**: Disease prediction\n- **Finance**: Trading strategies"
    },
    {
      "id": "wwdc-ui",
      "title": "WWDC UI - Swift Challenge Design",
      "category": "html",
      "subcategories": ["ui-design", "swift", "apple", "wwdc"],
      "time": "2025-01",
      "timeDisplay": "January 2025",
      "description": "UI design project for WWDC Swift Student Challenge",
      "tech": ["HTML", "CSS", "JavaScript", "Swift"],
      "github": "https://github.com/neilhuang007/WWDC-UI",
      "demo": "",
      "featured": false,
      "content": "## WWDC UI - Swift Challenge Design\n\nA creative UI design project developed for the WWDC Swift Student Challenge, showcasing innovative interface concepts.\n\n### Project Highlights\n\n- **Modern Design**: Following Apple's design guidelines\n- **Interactive Elements**: Engaging user interactions\n- **Responsive Layout**: Adaptive to different screens\n- **Animation**: Smooth transitions and effects\n\n### Technical Implementation\n\n- **Web Technologies**: HTML5, CSS3, JavaScript\n- **Design Principles**: Apple HIG compliance\n- **Performance**: Optimized animations\n- **Accessibility**: WCAG compliance\n\n### Design Features\n\n- Custom animations\n- Gesture recognition\n- Dark mode support\n- Accessibility features\n\n### Purpose\n\n- **Competition**: WWDC Swift Challenge submission\n- **Portfolio**: Demonstrating UI/UX skills\n- **Learning**: Swift and web integration\n- **Innovation**: Pushing design boundaries"
    },
    {
      "id": "swift-development",
      "title": "Swift Development Resources",
      "category": "html",
      "subcategories": ["swift", "ios", "documentation", "learning"],
      "time": "2023-11",
      "timeDisplay": "November 2023",
      "description": "Comprehensive Swift development resources and documentation",
      "tech": ["HTML", "CSS", "JavaScript", "Swift"],
      "github": "https://github.com/neilhuang007/SwiftDevelopement",
      "demo": "",
      "featured": false,
      "license": "MIT",
      "content": "## Swift Development Resources\n\nA curated collection of Swift development resources, tutorials, and documentation for iOS developers.\n\n### Content Categories\n\n- **Tutorials**: Step-by-step guides\n- **Best Practices**: Coding standards\n- **Code Examples**: Practical implementations\n- **Resources**: Tools and libraries\n\n### Topics Covered\n\n- Swift language fundamentals\n- iOS app architecture\n- SwiftUI and UIKit\n- Performance optimization\n- Testing strategies\n\n### Features\n\n- Searchable documentation\n- Code syntax highlighting\n- Interactive examples\n- Download resources\n\n### Target Audience\n\n- **Beginners**: Learning Swift basics\n- **Intermediate**: Advanced concepts\n- **Professionals**: Best practices\n- **Educators**: Teaching materials"
    },
    {
      "id": "shadowstrike",
      "title": "ShadowStrike - Security Framework",
      "category": "unknown",
      "subcategories": ["security", "framework", "tools"],
      "time": "2023-11",
      "timeDisplay": "November 2023",
      "description": "Security-focused framework project",
      "tech": ["Unknown"],
      "github": "https://github.com/neilhuang007/ShadowStrike",
      "demo": "",
      "featured": false,
      "license": "MIT",
      "content": "## ShadowStrike - Security Framework\n\nA security-focused framework project designed for advanced security operations and testing.\n\n### Project Overview\n\n- **Purpose**: Security testing framework\n- **Focus**: Comprehensive security tools\n- **Architecture**: Modular design\n- **License**: MIT License\n\n### Potential Features\n\n- Security assessment tools\n- Vulnerability scanning\n- Penetration testing utilities\n- Reporting capabilities\n\n### Technical Stack\n\n- Core framework implementation\n- Plugin architecture\n- API integration\n- Command-line interface\n\n### Applications\n\n- **Security Testing**: Vulnerability assessment\n- **Research**: Security methodology\n- **Education**: Learning security concepts\n- **Development**: Security tool creation"
    },
    {
      "id": "skidsuite",
      "title": "SkidSuite - Java Deobfuscation Tools",
      "category": "java",
      "subcategories": ["reverse-engineering", "deobfuscation", "security", "java-tools"],
      "time": "2025-01",
      "timeDisplay": "January 2025",
      "description": "Fork of threadtear inspired by GenericException's project for Java deobfuscation",
      "tech": ["Java", "ASM", "JavaFX"],
      "github": "https://github.com/neilhuang007/SkidSuite",
      "demo": "",
      "featured": false,
      "content": "## SkidSuite - Java Deobfuscation Tools\n\nA comprehensive suite of tools for analyzing and deobfuscating Java applications, inspired by GenericException's work and forked from threadtear.\n\n### Core Features\n\n- **Deobfuscation**: Multiple obfuscator support\n- **Analysis**: Code flow analysis\n- **Automation**: Batch processing\n- **Extensibility**: Plugin system\n\n### Supported Obfuscators\n\n- ZKM\n- Stringer\n- Allatori\n- DashO\n- Custom obfuscators\n\n### Technical Implementation\n\n- **Bytecode Analysis**: ASM framework\n- **Pattern Recognition**: Obfuscation detection\n- **Transformation**: Code simplification\n- **GUI**: JavaFX interface\n\n### Use Cases\n\n- **Malware Analysis**: Understanding obfuscated threats\n- **Software Auditing**: Code review\n- **Research**: Obfuscation techniques\n- **Education**: Learning bytecode manipulation"
    },
    {
      "id": "espada",
      "title": "Espada - Game Enhancement Tool",
      "category": "unknown",
      "subcategories": ["gaming", "tools", "enhancement"],
      "time": "2022-09",
      "timeDisplay": "September 2022",
      "description": "Fork of gaming enhancement tool from AbyssGG",
      "tech": ["Unknown"],
      "github": "https://github.com/neilhuang007/Espada",
      "demo": "",
      "featured": false,
      "content": "## Espada - Game Enhancement Tool\n\nA fork of the Espada project from AbyssGG, focused on gaming enhancements and modifications.\n\n### Project Overview\n\n- **Origin**: Fork from AbyssGG/Espada\n- **Purpose**: Game enhancement framework\n- **Last Update**: September 2022\n- **Status**: Archived/Legacy\n\n### Potential Features\n\n- Game modification tools\n- Performance enhancements\n- Custom overlays\n- Configuration management\n\n### Technical Aspects\n\n- Gaming framework integration\n- Memory management\n- Rendering hooks\n- Input handling\n\n### Legacy Value\n\n- **Historical**: Early game modding\n- **Educational**: Learning from past projects\n- **Reference**: Code examples\n- **Foundation**: Base for newer projects"
    },
    {
      "id": "trollhack",
      "title": "TrollHack - Kotlin Game Client",
      "category": "kotlin",
      "subcategories": ["minecraft", "gaming", "client", "kotlin"],
      "time": "2022-03",
      "timeDisplay": "March 2022",
      "description": "Fork of Minecraft game client written in Kotlin",
      "tech": ["Kotlin", "Gradle", "OpenGL"],
      "github": "https://github.com/neilhuang007/TrollHack",
      "demo": "",
      "featured": false,
      "content": "## TrollHack - Kotlin Game Client\n\nA Minecraft game client fork written in Kotlin, demonstrating modern JVM language usage in game modification.\n\n### Technical Highlights\n\n- **Language**: Pure Kotlin implementation\n- **Architecture**: Coroutine-based design\n- **Performance**: JVM optimizations\n- **Build System**: Gradle Kotlin DSL\n\n### Features\n\n- Modern Kotlin syntax\n- Null safety\n- Extension functions\n- Coroutines for async operations\n\n### Development Focus\n\n- **Code Quality**: Clean Kotlin code\n- **Performance**: Efficient implementations\n- **Maintainability**: Modern patterns\n- **Learning**: Kotlin in game development\n\n### Educational Value\n\n- Kotlin language features\n- Game client architecture\n- JVM performance optimization\n- Modern development practices"
    }
  ],
  "categories": {
    "python": {
      "name": "Python",
      "description": "Machine learning, data analysis, and automation projects",
      "count": 4
    },
    "java": {
      "name": "Java",
      "description": "Game modifications, reverse engineering, and enterprise applications",
      "count": 8
    },
    "javascript": {
      "name": "JavaScript",
      "description": "Web applications, browser extensions, and Node.js projects",
      "count": 5
    },
    "c": {
      "name": "C/C++",
      "description": "System programming, kernel development, and performance-critical applications",
      "count": 2
    },
    "html": {
      "name": "HTML/Web",
      "description": "Websites, documentation, and web-based tools",
      "count": 5
    },
    "typescript": {
      "name": "TypeScript",
      "description": "Type-safe web applications and modern frontend development",
      "count": 1
    },
    "kotlin": {
      "name": "Kotlin",
      "description": "Modern JVM language projects and Android development",
      "count": 1
    },
    "unknown": {
      "name": "Other/Unknown",
      "description": "Projects with unspecified or multiple languages",
      "count": 2
    }
  }
}